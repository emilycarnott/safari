<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catching Things Idle Game</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the timer bar */
        #timer-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 9999px; /* Tailwind's rounded-full */
            overflow: hidden; /* Ensure the bar stays within bounds */
        }

        #timer-bar {
            height: 24px; /* Tailwind's h-6 */
            background-color: #4CAF50; /* Green color for progress */
            width: 100%; /* Starts full, decreases */
            border-radius: 9999px; /* Tailwind's rounded-full */
            transition: width linear; /* Smooth transition for the timer bar */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.875rem; /* Tailwind's text-sm */
        }

        /* Style for locked regions */
        .locked-region-button {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Responsive height for region selector and collection list */
        @media (min-width: 768px) {
            #region-selector-list, #collection-list-container {
                max-height: calc(100vh - 200px); /* Adjust as needed for better fit */
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4 font-sans text-inter">
    <div id="game-container" class="flex flex-col md:flex-row bg-white rounded-lg shadow-xl p-6 w-full max-w-6xl h-[80vh] min-h-[600px]">
        <!-- Region Selector Area -->
        <div class="md:w-1/5 p-4 flex flex-col bg-gray-50 rounded-l-lg md:rounded-bl-none rounded-tl-lg md:border-r border-gray-200 shadow-inner overflow-y-auto">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Regions</h2>
            <div id="region-selector-list" class="flex-1 space-y-2 pb-4">
                <!-- Region buttons will be dynamically inserted here -->
                <p class="text-gray-500 italic">Loading regions...</p>
            </div>
        </div>

        <!-- Main Encounter Area -->
        <div id="main-encounter-area" class="flex-1 p-4 flex flex-col items-center justify-center space-y-6 rounded-lg md:rounded-none md:rounded-r-lg bg-cover bg-center transition-all duration-500 ease-in-out" style="background-image: url('https://placehold.co/800x600/6B8E23/FFFFFF?text=Loading+Region...'); background-color: #6B8E23;">
            <h1 class="text-3xl font-bold text-white text-shadow-md drop-shadow-lg mb-4">
                Current Encounter in <span id="current-region-name-display">Loading...</span>
            </h1>

            <div class="bg-blue-100 bg-opacity-80 rounded-lg p-4 shadow-md text-center w-full max-w-sm border-2 border-blue-300">
                <h2 class="text-2xl font-semibold text-blue-800 mb-2">
                    <span id="encounter-name">Loading encounters...</span>
                </h2>
                <img id="encounter-image" src="https://placehold.co/200x200/cccccc/333333?text=Loading..." alt="Encountered Item" class="w-48 h-48 rounded-lg object-cover mx-auto shadow-md border-2 border-blue-300">
            </div>

            <!-- Timer Bar -->
            <div id="timer-container" class="w-full max-w-sm mt-6 shadow-inner">
                <div id="timer-bar" class="h-6 bg-gradient-to-r from-green-400 to-green-600 flex items-center justify-center text-white text-sm font-bold rounded-full" style="width: 100%;">
                    Next Encounter in <span id="timer-text">15</span>s
                </div>
            </div>
        </div>

        <!-- Collection Area -->
        <div class="md:w-1/4 p-4 md:pl-8 mt-8 md:mt-0 flex flex-col bg-gray-50 rounded-r-lg md:rounded-tr-none rounded-br-lg shadow-inner overflow-y-auto">
            <h1 class="text-3xl font-bold text-gray-800 mb-4">Your Collection</h1>
            <div id="collection-list-container" class="bg-yellow-100 rounded-lg p-4 shadow-md flex-1 overflow-y-auto">
                <ul id="collection-list" class="space-y-2">
                    <!-- Collection items will be added here -->
                    <li class="text-gray-500 italic">No items collected yet.</li>
                </ul>
            </div>
            <!-- Total Points Display -->
            <div class="mt-4 p-3 bg-purple-100 rounded-lg shadow-md text-center">
                <h2 class="text-xl font-semibold text-purple-800">Total Points: <span id="total-points-display" class="text-2xl font-bold text-purple-900">0</span></h2>
            </div>
        </div>
    </div>

    <script type="module">
        // Define the URLs for your CSV data files
        // IMPORTANT: Replace these with the actual URLs to your CSV files on GitHub Pages.
        // encounters.csv expects 6 columns: ID, Name, Image URL, Region, Rarity, Points
        const ENCOUNTERS_CSV_URL = 'https://raw.githubusercontent.com/google/gemini-canvas-example-data/main/encounters_with_points.csv';
        // regions.csv expects 4 columns: ID, Name, Image URL, Unlock Points
        const REGIONS_CSV_URL = 'https://raw.githubusercontent.com/google/gemini-canvas-example-data/main/regions.csv';

        // Constants for game timing
        const ENCOUNTER_DURATION_MS = 15 * 1000; // 15 seconds in milliseconds

        // DOM elements
        const mainEncounterArea = document.getElementById('main-encounter-area'); // New: For region background
        const encounterNameElement = document.getElementById('encounter-name');
        const encounterImageElement = document.getElementById('encounter-image');
        const timerBarElement = document.getElementById('timer-bar');
        const timerTextElement = document.getElementById('timer-text');
        const collectionListElement = document.getElementById('collection-list');
        const currentRegionNameDisplay = document.getElementById('current-region-name-display'); // Renamed
        const regionSelectorList = document.getElementById('region-selector-list'); // New: Container for region buttons
        const totalPointsDisplay = document.getElementById('total-points-display');

        // Game state variables
        let encounterData = []; // Populated from encounters.csv
        let regionData = [];    // New: Populated from regions.csv
        const collectedItems = new Set();
        let encounterIntervalId = null;
        let timerAnimationId = null;
        let timerCountdownMs = ENCOUNTER_DURATION_MS;
        let lastAnimationFrameTime = 0;
        let currentRegionId = 1; // Start in Region 1 (by ID)
        let currentRegionObject = null; // New: Stores the full object of the current region
        let totalPoints = 0;

        /**
         * Fetches and parses CSV data from the specified URL.
         * @param {string} url - The URL of the CSV file.
         * @param {function(string): Array<Object>} parserFunction - The function to parse the CSV text.
         * @returns {Promise<Array<Object>>} A promise that resolves with an array of parsed objects.
         */
        async function fetchCSVData(url, parserFunction) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                return parserFunction(csvText);
            } catch (error) {
                console.error(`Error fetching or parsing CSV from ${url}:`, error);
                return [];
            }
        }

        /**
         * Parses encounters CSV text into an array of objects.
         * Expects columns: ID, Name, Image URL, Region, Rarity, Points
         * @param {string} csvText - The raw CSV content as a string.
         * @returns {Array<Object>} An array of objects, each representing an encounter.
         */
        function parseEncountersCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length === 0) return [];
            return lines.slice(1).map(line => {
                const parts = line.split(',');
                if (parts.length >= 6) {
                    return {
                        id: parts[0].trim(),
                        name: parts[1].trim(),
                        imageUrl: parts[2].trim(),
                        region: parseInt(parts[3].trim(), 10),
                        rarity: parseInt(parts[4].trim(), 10),
                        points: parseInt(parts[5].trim(), 10)
                    };
                }
                return null;
            }).filter(item => item !== null);
        }

        /**
         * Parses regions CSV text into an array of objects.
         * Expects columns: ID, Name, Image URL, Unlock Points
         * @param {string} csvText - The raw CSV content as a string.
         * @returns {Array<Object>} An array of objects, each representing a region.
         */
        function parseRegionsCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length === 0) return [];
            return lines.slice(1).map(line => {
                const parts = line.split(',');
                if (parts.length >= 4) {
                    return {
                        id: parseInt(parts[0].trim(), 10),
                        name: parts[1].trim(),
                        imageUrl: parts[2].trim(),
                        unlockPoints: parseInt(parts[3].trim(), 10)
                    };
                }
                return null;
            }).filter(item => item !== null);
        }

        /**
         * Selects a random item from the encounterData array, filtered by the current region,
         * using a weighted random selection based on item rarity.
         * @returns {Object} A random encounter item or a placeholder if no data for the region.
         */
        function getRandomEncounterItem() {
            const regionalEncounters = encounterData.filter(item => item.region === currentRegionId);

            if (regionalEncounters.length === 0) {
                return { name: `No encounters in ${currentRegionObject ? currentRegionObject.name : 'this region'}`, imageUrl: "https://placehold.co/200x200/FF0000/FFFFFF?text=No+Encounters", points: 0 };
            }

            let totalWeight = 0;
            const weightedEncounters = regionalEncounters.map(item => {
                const weight = item.rarity > 0 ? 1 / item.rarity : 1;
                totalWeight += weight;
                return { ...item, weight: weight };
            });

            let randomValue = Math.random() * totalWeight;

            for (const item of weightedEncounters) {
                randomValue -= item.weight;
                if (randomValue <= 0) {
                    return item;
                }
            }
            return regionalEncounters[0];
        }

        /**
         * Updates the collection display on the UI.
         */
        function updateCollectionDisplay() {
            collectionListElement.innerHTML = '';

            if (collectedItems.size === 0) {
                collectionListElement.innerHTML = '<li class="text-gray-500 italic">No items collected yet.</li>';
                return;
            }

            collectedItems.forEach(itemName => {
                const listItem = document.createElement('li');
                listItem.className = 'bg-yellow-200 text-yellow-800 p-2 rounded-md shadow-sm flex items-center justify-between';
                listItem.innerHTML = `<span>${itemName}</span> <span class="text-sm font-semibold text-green-700">NEW!</span>`;
                collectionListElement.appendChild(listItem);
            });
        }

        /**
         * Updates the total points display on the UI.
         */
        function updateTotalPointsDisplay() {
            totalPointsDisplay.textContent = totalPoints;
            renderRegionSelection(); // Re-render region buttons to update locked/unlocked state
        }

        /**
         * Processes an encounter: updates UI, checks for new items, adds to collection.
         */
        function processEncounter() {
            const item = getRandomEncounterItem();

            encounterNameElement.textContent = item.name;
            encounterImageElement.src = item.imageUrl;
            encounterImageElement.alt = item.name;

            if (!collectedItems.has(item.name)) {
                collectedItems.add(item.name);
                totalPoints += item.points;
                console.log(`New item collected: ${item.name}, Points gained: ${item.points}`);
                updateCollectionDisplay();
                updateTotalPointsDisplay();
            } else {
                console.log(`Encountered ${item.name} again.`);
            }

            timerCountdownMs = ENCOUNTER_DURATION_MS;
            lastAnimationFrameTime = performance.now();
            if (timerAnimationId) {
                cancelAnimationFrame(timerAnimationId);
            }
            timerAnimationId = requestAnimationFrame(animateTimerBar);
        }

        /**
         * Animates the timer bar and updates the countdown text.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function animateTimerBar(currentTime) {
            if (!lastAnimationFrameTime) {
                lastAnimationFrameTime = currentTime;
            }

            const elapsed = currentTime - lastAnimationFrameTime;
            lastAnimationFrameTime = currentTime;

            timerCountdownMs -= elapsed;

            if (timerCountdownMs < 0) {
                timerCountdownMs = 0;
            }

            const progress = (timerCountdownMs / ENCOUNTER_DURATION_MS) * 100;
            timerBarElement.style.width = `${progress}%`;

            const secondsLeft = Math.ceil(timerCountdownMs / 1000);
            timerTextElement.textContent = secondsLeft;

            if (timerCountdownMs > 0) {
                timerAnimationId = requestAnimationFrame(animateTimerBar);
            } else {
                timerTextElement.textContent = '0';
            }
        }

        /**
         * Renders (or re-renders) the region selection buttons based on regionData and totalPoints.
         */
        function renderRegionSelection() {
            regionSelectorList.innerHTML = ''; // Clear existing buttons

            if (regionData.length === 0) {
                regionSelectorList.innerHTML = '<p class="text-gray-500 italic">No regions loaded.</p>';
                return;
            }

            regionData.forEach(region => {
                const button = document.createElement('button');
                const isLocked = totalPoints < region.unlockPoints;
                const isActive = region.id === currentRegionId;

                button.textContent = `${region.name} ${isLocked ? `(${region.unlockPoints} pts)` : ''}`;
                button.className = `w-full px-4 py-2 rounded-lg font-bold shadow-md transition-all duration-200 text-left`;

                if (isActive) {
                    button.classList.add('bg-blue-600', 'text-white', 'hover:scale-105');
                } else if (isLocked) {
                    button.classList.add('bg-gray-300', 'text-gray-600', 'locked-region-button');
                    button.disabled = true; // Disable interaction for locked regions
                } else {
                    button.classList.add('bg-blue-500', 'text-blue-50', 'hover:bg-blue-600', 'hover:scale-105');
                    button.addEventListener('click', () => changeRegion(region.id));
                }
                regionSelectorList.appendChild(button);
            });
        }


        /**
         * Changes the active region of the game.
         * @param {number} newRegionId - The ID of the region to switch to.
         */
        function changeRegion(newRegionId) {
            if (currentRegionId === newRegionId) {
                return; // Do nothing if already in this region
            }

            const newRegion = regionData.find(r => r.id === newRegionId);
            if (!newRegion) {
                console.error(`Region with ID ${newRegionId} not found.`);
                return;
            }

            if (totalPoints < newRegion.unlockPoints) {
                console.log(`Not enough points to unlock ${newRegion.name}. Need ${newRegion.unlockPoints} points.`);
                // Optionally, add a temporary message to the UI here
                return;
            }

            currentRegionId = newRegionId;
            currentRegionObject = newRegion; // Update the full object
            updateRegionDisplay(); // Update UI for active region and background
            updateCollectionDisplay(); // Re-render collection display if needed

            // The existing setInterval will trigger the next encounter
            // at its scheduled time, using the new currentRegionId.
        }

        /**
         * Updates the current region name display and sets the background image.
         */
        function updateRegionDisplay() {
            if (currentRegionObject) {
                currentRegionNameDisplay.textContent = currentRegionObject.name;
                mainEncounterArea.style.backgroundImage = `url('${currentRegionObject.imageUrl}')`;
            } else {
                currentRegionNameDisplay.textContent = 'Unknown Region';
                mainEncounterArea.style.backgroundImage = `url('https://placehold.co/800x600/FF0000/FFFFFF?text=Region+Not+Found')`;
            }
            renderRegionSelection(); // Re-render buttons to highlight active
        }

        /**
         * Starts the game by initializing data, UI, and the encounter interval.
         */
        async function startGame() {
            // Display loading state
            encounterNameElement.textContent = 'Loading game data...';
            encounterImageElement.src = 'https://placehold.co/200x200/cccccc/333333?text=Loading...';
            encounterImageElement.alt = 'Loading...';
            currentRegionNameDisplay.textContent = 'Loading...';

            // Fetch and parse both CSV data files concurrently
            const [encounters, regions] = await Promise.all([
                fetchCSVData(ENCOUNTERS_CSV_URL, parseEncountersCSV),
                fetchCSVData(REGIONS_CSV_URL, parseRegionsCSV)
            ]);

            encounterData = encounters;
            regionData = regions.sort((a, b) => a.id - b.id); // Sort regions by ID for consistent display

            console.log("Loaded Region Data:", regionData); // <-- CHECK YOUR BROWSER'S CONSOLE FOR THIS!

            if (encounterData.length === 0 || regionData.length === 0) {
                console.error('Failed to load all necessary game data. Game cannot start.');
                encounterNameElement.textContent = 'Game data failed to load.';
                currentRegionNameDisplay.textContent = 'Error';
                mainEncounterArea.style.backgroundImage = `url('https://placehold.co/800x600/FF0000/FFFFFF?text=Error+Loading')`;
                return;
            }

            // Set initial current region object and ID to the first loaded region
            // This ensures currentRegionId always matches an existing region's ID
            currentRegionObject = regionData[0]; // Assume regionData is sorted and not empty
            currentRegionId = regionData[0].id; // Set currentRegionId to the ID of the first region

            // Initial setup for collection, region display, and points
            updateCollectionDisplay();
            updateTotalPointsDisplay(); // This will call renderRegionSelection
            updateRegionDisplay(); // Set initial region name and background

            // Perform the first encounter immediately for the starting region
            processEncounter();

            // Set up the interval for subsequent encounters
            encounterIntervalId = setInterval(processEncounter, ENCOUNTER_DURATION_MS);
        }

        // Start the game when the window loads
        window.onload = startGame;

        // Cleanup on page unload (optional, but good practice for long-running intervals)
        window.onbeforeunload = () => {
            if (encounterIntervalId) {
                clearInterval(encounterIntervalId);
            }
            if (timerAnimationId) {
                cancelAnimationFrame(timerAnimationId);
            }
        };
    </script>
</body>
</html>
