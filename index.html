<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catching Things Idle Game</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the timer bar */
        #timer-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 9999px; /* Tailwind's rounded-full */
            overflow: hidden; /* Ensure the bar stays within bounds */
        }

        #timer-bar {
            height: 24px; /* Tailwind's h-6 */
            background-color: #4CAF50; /* Green color for progress */
            width: 100%; /* Starts full, decreases */
            border-radius: 9999px; /* Tailwind's rounded-full */
            transition: width linear; /* Smooth transition for the timer bar */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.875rem; /* Tailwind's text-sm */
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4 font-sans text-inter">
    <div id="game-container" class="flex flex-col md:flex-row bg-white rounded-lg shadow-xl p-6 w-full max-w-4xl">
        <!-- Encounter Area -->
        <div class="flex-1 p-4 flex flex-col items-center justify-center space-y-6 md:border-r md:border-gray-200">
            <h1 class="text-3xl font-bold text-gray-800 mb-4">Current Encounter</h1>

            <!-- Region Selection -->
            <div class="flex flex-col items-center space-y-2 mb-4">
                <span id="current-region-display" class="text-xl font-semibold text-gray-700">Current: Region 1</span>
                <div class="flex space-x-2">
                    <button id="region-1-button" class="px-4 py-2 rounded-lg bg-blue-600 text-white font-bold shadow-md hover:scale-105 transition-transform duration-200">Region 1</button>
                    <button id="region-2-button" class="px-4 py-2 rounded-lg bg-blue-500 text-blue-50 font-bold shadow-md hover:bg-blue-600 hover:scale-105 transition-transform duration-200">Region 2</button>
                </div>
            </div>

            <div class="bg-blue-100 rounded-lg p-4 shadow-md text-center w-full max-w-sm">
                <h2 class="text-2xl font-semibold text-blue-800 mb-2">
                    <span id="encounter-name">Loading encounters...</span>
                </h2>
                <img id="encounter-image" src="https://placehold.co/200x200/cccccc/333333?text=Loading..." alt="Encountered Item" class="w-48 h-48 rounded-lg object-cover mx-auto shadow-md border-2 border-blue-300">
            </div>

            <!-- Timer Bar -->
            <div id="timer-container" class="w-full max-w-sm mt-6 shadow-inner">
                <div id="timer-bar" class="h-6 bg-gradient-to-r from-green-400 to-green-600 flex items-center justify-center text-white text-sm font-bold rounded-full" style="width: 100%;">
                    Next Encounter in <span id="timer-text">15</span>s
                </div>
            </div>
        </div>

        <!-- Collection Area -->
        <div class="flex-1 p-4 md:pl-8 mt-8 md:mt-0">
            <h1 class="text-3xl font-bold text-gray-800 mb-4">Your Collection</h1>
            <div class="bg-yellow-100 rounded-lg p-4 shadow-md h-96 overflow-y-auto">
                <ul id="collection-list" class="space-y-2">
                    <!-- Collection items will be added here -->
                    <li class="text-gray-500 italic">No items collected yet.</li>
                </ul>
            </div>
            <!-- Total Points Display -->
            <div class="mt-4 p-3 bg-purple-100 rounded-lg shadow-md text-center">
                <h2 class="text-xl font-semibold text-purple-800">Total Points: <span id="total-points-display" class="text-2xl font-bold text-purple-900">0</span></h2>
            </div>
        </div>
    </div>

    <script type="module">
        // Define the URL for your CSV data
        // IMPORTANT: Replace this with the actual URL to your CSV file on GitHub Pages.
        // This CSV now expects 6 columns: ID, Name, Image URL, Region, Rarity, Points
        const CSV_URL = 'https://raw.githubusercontent.com/emilycarnott/safari/refs/heads/main/encounters.csv';

        // Constants for game timing
        const ENCOUNTER_DURATION_MS = 15 * 1000; // 15 seconds in milliseconds

        // DOM elements
        const encounterNameElement = document.getElementById('encounter-name');
        const encounterImageElement = document.getElementById('encounter-image');
        const timerBarElement = document.getElementById('timer-bar');
        const timerTextElement = document.getElementById('timer-text');
        const collectionListElement = document.getElementById('collection-list');
        const currentRegionDisplay = document.getElementById('current-region-display');
        const region1Button = document.getElementById('region-1-button');
        const region2Button = document.getElementById('region-2-button');
        const totalPointsDisplay = document.getElementById('total-points-display'); // New: Points display element

        // Game state variables
        let encounterData = []; // This will now be populated from the CSV
        const collectedItems = new Set(); // Using a Set to store unique item names
        let encounterIntervalId = null; // Stores the ID of the setInterval
        let timerAnimationId = null; // Stores the ID of the requestAnimationFrame
        let timerCountdownMs = ENCOUNTER_DURATION_MS; // Current countdown for the bar
        let lastAnimationFrameTime = 0; // Timestamp of the last animation frame
        let currentRegion = 1; // Start in Region 1
        let totalPoints = 0; // New: Accumulated points

        /**
         * Fetches and parses CSV data from the specified URL.
         * Assumes CSV has columns: ID, Name, Image URL, Region, Rarity, Points.
         * @returns {Promise<Array<Object>>} A promise that resolves with an array of encounter objects.
         */
        async function fetchEncounterData() {
            try {
                const response = await fetch(CSV_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                return parseCSV(csvText);
            } catch (error) {
                console.error('Error fetching or parsing CSV:', error);
                encounterNameElement.textContent = 'Error loading data.';
                encounterImageElement.src = 'https://placehold.co/200x200/FF0000/FFFFFF?text=Error';
                encounterImageElement.alt = 'Error';
                return []; // Return empty array on error
            }
        }

        /**
         * Parses CSV text into an array of objects.
         * Assumes the first line is the header, and subsequent lines are data.
         * Expects columns: ID, Name, Image URL, Region, Rarity, Points (in that order, zero-indexed 0, 1, 2, 3, 4, 5)
         * @param {string} csvText - The raw CSV content as a string.
         * @returns {Array<Object>} An array of objects, each representing an encounter.
         */
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length === 0) return [];

            // Skip header and process data rows
            const data = lines.slice(1).map(line => {
                const parts = line.split(','); // Simple split assuming no commas within fields
                // Ensure there are enough parts before accessing them (expecting at least 6)
                if (parts.length >= 6) {
                    return {
                        id: parts[0].trim(),
                        name: parts[1].trim(),
                        imageUrl: parts[2].trim(),
                        region: parseInt(parts[3].trim(), 10), // Parse region as an integer
                        rarity: parseInt(parts[4].trim(), 10),  // Parse rarity as an integer
                        points: parseInt(parts[5].trim(), 10)  // Parse points as an integer
                    };
                }
                return null; // Skip malformed rows
            }).filter(item => item !== null); // Filter out any null entries from malformed rows
            return data;
        }

        /**
         * Selects a random item from the encounterData array, filtered by the current region,
         * using a weighted random selection based on item rarity.
         * @returns {Object} A random encounter item or a placeholder if no data for the region.
         */
        function getRandomEncounterItem() {
            // Filter encounters by current region
            const regionalEncounters = encounterData.filter(item => item.region === currentRegion);

            if (regionalEncounters.length === 0) {
                return { name: `No encounters in Region ${currentRegion}`, imageUrl: "https://placehold.co/200x200/FF0000/FFFFFF?text=No+Encounters", points: 0 }; // Add points: 0 to placeholder
            }

            // Calculate total weight for weighted random selection
            let totalWeight = 0;
            const weightedEncounters = regionalEncounters.map(item => {
                // Weight is inverse of rarity. Rarity of 0 or less would be problematic, default to 1.
                const weight = item.rarity > 0 ? 1 / item.rarity : 1;
                totalWeight += weight;
                return { ...item, weight: weight };
            });

            // Generate a random value within the total weight
            let randomValue = Math.random() * totalWeight;

            // Iterate through weighted encounters to find the selected item
            for (const item of weightedEncounters) {
                randomValue -= item.weight;
                if (randomValue <= 0) {
                    return item; // This is the chosen item
                }
            }

            // Fallback in case of unexpected calculation (should not happen with correct logic)
            return regionalEncounters[0];
        }

        /**
         * Updates the collection display on the UI.
         */
        function updateCollectionDisplay() {
            // Clear existing list items
            collectionListElement.innerHTML = '';

            if (collectedItems.size === 0) {
                collectionListElement.innerHTML = '<li class="text-gray-500 italic">No items collected yet.</li>';
                return;
            }

            // Add each collected item to the list
            collectedItems.forEach(itemName => {
                const listItem = document.createElement('li');
                listItem.className = 'bg-yellow-200 text-yellow-800 p-2 rounded-md shadow-sm flex items-center justify-between';
                listItem.innerHTML = `<span>${itemName}</span> <span class="text-sm font-semibold text-green-700">NEW!</span>`;
                collectionListElement.appendChild(listItem);
            });
        }

        /**
         * Updates the total points display on the UI.
         */
        function updateTotalPointsDisplay() {
            totalPointsDisplay.textContent = totalPoints;
        }

        /**
         * Processes an encounter: updates UI, checks for new items, adds to collection.
         */
        function processEncounter() {
            const item = getRandomEncounterItem();

            // Update encounter display
            encounterNameElement.textContent = item.name;
            encounterImageElement.src = item.imageUrl;
            encounterImageElement.alt = item.name;

            // Check if the item is new to the collection
            if (!collectedItems.has(item.name)) {
                collectedItems.add(item.name);
                totalPoints += item.points; // Add points when a new item is collected
                console.log(`New item collected: ${item.name}, Points gained: ${item.points}`);
                updateCollectionDisplay(); // Update collection UI
                updateTotalPointsDisplay(); // Update points UI
            } else {
                console.log(`Encountered ${item.name} again.`);
            }

            // Reset timer for the next encounter
            timerCountdownMs = ENCOUNTER_DURATION_MS;
            lastAnimationFrameTime = performance.now(); // Reset timestamp for smooth animation
            if (timerAnimationId) {
                cancelAnimationFrame(timerAnimationId); // Stop previous animation if running
            }
            timerAnimationId = requestAnimationFrame(animateTimerBar); // Start new animation
        }

        /**
         * Animates the timer bar and updates the countdown text.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function animateTimerBar(currentTime) {
            if (!lastAnimationFrameTime) {
                lastAnimationFrameTime = currentTime;
            }

            const elapsed = currentTime - lastAnimationFrameTime;
            lastAnimationFrameTime = currentTime;

            timerCountdownMs -= elapsed;

            if (timerCountdownMs < 0) {
                timerCountdownMs = 0;
            }

            // Calculate progress for the bar (0% to 100%)
            const progress = (timerCountdownMs / ENCOUNTER_DURATION_MS) * 100;
            timerBarElement.style.width = `${progress}%`;

            // Update countdown text (rounded up)
            const secondsLeft = Math.ceil(timerCountdownMs / 1000);
            timerTextElement.textContent = secondsLeft;

            // Continue animation if time is still running
            if (timerCountdownMs > 0) {
                timerAnimationId = requestAnimationFrame(animateTimerBar);
            } else {
                // When countdown finishes, ensure bar is at 0%
                timerTextElement.textContent = '0';
            }
        }

        /**
         * Changes the active region of the game.
         * @param {number} regionNum - The region number to switch to (e.g., 1 or 2).
         */
        function changeRegion(regionNum) {
            if (currentRegion === regionNum) {
                return; // Do nothing if already in this region
            }

            currentRegion = regionNum;
            updateCollectionDisplay(); // Update to reflect any collection changes if items were added while in another region
            updateRegionDisplay(); // Update UI for active region

            // No immediate encounter: The existing setInterval will trigger the next encounter
            // at its scheduled time, and getRandomEncounterItem will then use the new currentRegion.
        }

        /**
         * Updates the current region display text and highlights the active region button.
         */
        function updateRegionDisplay() {
            currentRegionDisplay.textContent = `Current: Region ${currentRegion}`;

            // Reset all button styles to default
            region1Button.classList.remove('bg-blue-600', 'text-white');
            region1Button.classList.add('bg-blue-500', 'hover:bg-blue-600', 'text-blue-50');

            region2Button.classList.remove('bg-blue-600', 'text-white');
            region2Button.classList.add('bg-blue-500', 'hover:bg-blue-600', 'text-blue-50');

            // Apply active style to the current region's button
            if (currentRegion === 1) {
                region1Button.classList.add('bg-blue-600', 'text-white');
                region1Button.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'text-blue-50');
            } else if (currentRegion === 2) {
                region2Button.classList.add('bg-blue-600', 'text-white');
                region2Button.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'text-blue-50');
            }
        }

        /**
         * Starts the game by initiating the first encounter and setting up the interval.
         * This now waits for CSV data to load and sets up region selection.
         */
        async function startGame() {
            // Display loading state
            encounterNameElement.textContent = 'Loading encounters...';
            encounterImageElement.src = 'https://placehold.co/200x200/cccccc/333333?text=Loading...';
            encounterImageElement.alt = 'Loading...';

            // Fetch and parse the encounter data from CSV
            encounterData = await fetchEncounterData();

            if (encounterData.length === 0) {
                console.error('No encounter data loaded. Game cannot start.');
                encounterNameElement.textContent = 'Failed to load encounters.';
                return; // Stop if no data
            }

            // Set up event listeners for region buttons
            region1Button.addEventListener('click', () => changeRegion(1));
            region2Button.addEventListener('click', () => changeRegion(2));

            // Initial setup for collection and region display
            updateCollectionDisplay();
            updateRegionDisplay(); // Call to set initial button state and text
            updateTotalPointsDisplay(); // Initialize points display

            // Perform the first encounter immediately for the starting region (Region 1)
            processEncounter();

            // Set up the interval for subsequent encounters
            encounterIntervalId = setInterval(processEncounter, ENCOUNTER_DURATION_MS);
        }

        // Start the game when the window loads
        window.onload = startGame;

        // Cleanup on page unload (optional, but good practice for long-running intervals)
        window.onbeforeunload = () => {
            if (encounterIntervalId) {
                clearInterval(encounterIntervalId);
            }
            if (timerAnimationId) {
                cancelAnimationFrame(timerAnimationId);
            }
        };
    </script>
</body>
</html>
