<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idle Safari</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the timer bar */
        #timer-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 9999px; /* Tailwind's rounded-full */
            overflow: hidden; /* Ensure the bar stays within bounds */
        }

        #timer-bar {
            height: 24px; /* Tailwind's h-6 */
            background-color: #4CAF50; /* Green color for progress */
            width: 100%; /* Starts full, decreases */
            border-radius: 9999px; /* Tailwind's rounded-full */
            transition: width linear; /* Smooth transition for the timer bar */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.875rem; /* Tailwind's text-sm */
        }

        /* Style for locked regions */
        .locked-region-button {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Responsive height adjustments for columns */
        @media (min-width: 768px) {
            .column-scroll-container {
                max-height: calc(100vh - 8rem);
                overflow-y: auto;
            }
            #game-container {
                height: 80vh;
                min-height: 600px;
                max-width: 80rem;
            }
        }

        /* Custom style for folder headers */
        .folder-header {
            background-color: #3B82F6; /* Tailwind blue-500 */
            color: white;
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Tailwind shadow-md */
            transition: background-color 0.2s, transform 0.2s;
        }

        .folder-header:hover {
            background-color: #2563EB; /* Tailwind blue-600 */
            transform: scale(1.02);
        }

        .folder-header .arrow-icon {
            transition: transform 0.2s;
        }

        .folder-header.collapsed .arrow-icon {
            transform: rotate(-90deg);
        }

        .folder-content {
            padding-left: 0.5rem; /* Indent regions inside folders */
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
        }
        .folder-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin-bottom: 0;
        }
        .folder-content:not(.collapsed) {
            max-height: 9999px; /* Increased to a very large value for smooth expansion */
            opacity: 1;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4 font-sans text-inter">
    <div id="game-container" class="flex flex-col md:flex-row bg-white rounded-lg shadow-xl p-6 w-full max-w-6xl">
        <!-- Region Selector Area -->
        <div class="md:w-1/5 p-4 flex flex-col bg-gray-50 rounded-l-lg md:rounded-bl-none rounded-tl-lg md:border-r border-gray-200 shadow-inner column-scroll-container">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Regions</h2>
            <div id="region-selector-list" class="flex-1 space-y-2 pb-4">
                <!-- Region folders and buttons will be dynamically inserted here -->
                <p class="text-gray-500 italic">Loading regions...</p>
            </div>
        </div>

        <!-- Main Encounter Area -->
        <div id="main-encounter-area" class="flex-1 p-4 flex flex-col items-center justify-center space-y-6 rounded-lg md:rounded-none md:rounded-r-lg bg-cover bg-center transition-all duration-500 ease-in-out" style="background-image: url('https://placehold.co/800x600/6B8E23/FFFFFF?text=Loading+Region...'); background-color: #6B8E23;">
            <h1 class="text-3xl font-bold text-white text-shadow-md drop-shadow-lg mb-4">
                Current Encounter in <span id="current-region-name-display">Loading...</span>
            </h1>

            <div class="bg-blue-100 bg-opacity-80 rounded-lg p-4 shadow-md text-center w-full max-w-sm border-2 border-blue-300">
                <h2 class="text-2xl font-semibold text-blue-800 mb-2">
                    <span id="encounter-name">Loading encounters...</span>
                </h2>
                <img id="encounter-image" src="https://placehold.co/200x200/cccccc/333333?text=Loading..." alt="Encountered Item" class="w-48 h-48 rounded-lg object-cover mx-auto shadow-md border-2 border-blue-300">
            </div>

            <!-- Timer Bar -->
            <div id="timer-container" class="w-full max-w-sm mt-6 shadow-inner">
                <div id="timer-bar" class="h-6 bg-gradient-to-r from-green-400 to-green-600 flex items-center justify-center text-white text-sm font-bold rounded-full" style="width: 100%;">
                    Next Encounter in <span id="timer-text">15</span>s
                </div>
            </div>
        </div>

        <!-- Right Column: Collection & Points -->
        <div class="md:w-1/4 p-4 md:pl-8 mt-8 md:mt-0 flex flex-col bg-gray-50 rounded-r-lg md:rounded-tr-none rounded-br-lg shadow-inner column-scroll-container">
            <!-- Total Points Display -->
            <div class="mb-4 p-3 bg-purple-100 rounded-lg shadow-md text-center flex-shrink-0">
                <h2 class="text-xl font-semibold text-purple-800">Total Points: <span id="total-points-display" class="text-2xl font-bold text-purple-900">0</span></h2>
            </div>

            <!-- Collection Area -->
            <h1 class="text-2xl font-bold text-gray-800 mb-2">Your Collection</h1>
            <div id="collection-list-container" class="bg-yellow-100 rounded-lg p-3 shadow-md mb-4 flex-1 overflow-y-auto">
                <ul id="collection-list" class="space-y-1">
                    <li class="text-gray-500 italic">No items collected yet.</li>
                </ul>
            </div>
        </div>
    </div>

    <script type="module">
        // Define the URLs for your CSV data files
        // IMPORTANT: Replace these with the actual URLs to your CSV files on GitHub Pages.
        // encounters.csv expects 6 columns: ID, Name, Image URL, Region, Rarity, Points
        const ENCOUNTERS_CSV_URL = 'https://raw.githubusercontent.com/google/gemini-canvas-example-data/main/encounters_with_points.csv';
        // regions.csv expects 5 columns: ID, Name, Image URL, Unlock Points, Folder
        const REGIONS_CSV_URL = 'https://raw.githubusercontent.com/google/gemini-canvas-example-data/main/regions_with_folders.csv';

        // Constants for game timing
        const ENCOUNTER_DURATION_MS = 15 * 1000; // 15 seconds in milliseconds

        // DOM elements
        const mainEncounterArea = document.getElementById('main-encounter-area');
        const encounterNameElement = document.getElementById('encounter-name');
        const encounterImageElement = document.getElementById('encounter-image');
        const timerBarElement = document.getElementById('timer-bar');
        const timerTextElement = document.getElementById('timer-text');
        const collectionListElement = document.getElementById('collection-list');
        const currentRegionNameDisplay = document.getElementById('current-region-name-display');
        const regionSelectorList = document.getElementById('region-selector-list');
        const totalPointsDisplay = document.getElementById('total-points-display');

        // Game state variables
        let encounterData = [];
        let regionData = [];
        const collectedItems = new Set();
        let encounterIntervalId = null;
        let timerAnimationId = null;
        let timerCountdownMs = ENCOUNTER_DURATION_MS;
        let lastAnimationFrameTime = 0;
        let currentRegionId = 1;
        let currentRegionObject = null;
        let totalPoints = 0;

        // Keep track of which folders are open/closed
        const folderStates = {}; // key: folder name, value: boolean (true for open, false for closed)


        /**
         * Fetches and parses CSV data from the specified URL.
         * @param {string} url - The URL of the CSV file.
         * @param {function(string): Array<Object>} parserFunction - The function to parse the CSV text.
         * @returns {Promise<Array<Object>>} A promise that resolves with an array of parsed objects.
         */
        async function fetchCSVData(url, parserFunction) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                return parserFunction(csvText);
            } catch (error) {
                console.error(`Error fetching or parsing CSV from ${url}:`, error);
                return [];
            }
        }

        /**
         * Parses encounters CSV text into an array of objects.
         * Expects columns: ID, Name, Image URL, Region, Rarity, Points
         * @param {string} csvText - The raw CSV content as a string.
         * @returns {Array<Object>} An array of objects, each representing an encounter.
         */
        function parseEncountersCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length === 0) return [];
            return lines.map(line => {
                const parts = line.split(',');
                if (parts.length >= 6) {
                    return {
                        id: parts[0].trim(), // Keep ID as string
                        name: parts[1].
trim(),
                        imageUrl: parts[2].trim(),
                        region: parseInt(parts[3].trim(), 10),
                        rarity: parseInt(parts[4].trim(), 10),
                        points: parseInt(parts[5].trim(), 10)
                    };
                }
                return null;
            }).filter(item => item !== null);
        }

        /**
         * Parses regions CSV text into an array of objects.
         * Expects columns: ID, Name, Image URL, Unlock Points, Folder
         * @param {string} csvText - The raw CSV content as a string.
         * @returns {Array<Object>} An array of objects, each representing a region.
         */
        function parseRegionsCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length === 0) return [];
            return lines.map(line => {
                const parts = line.split(',');
                if (parts.length >= 5) {
                    return {
                        id: parseInt(parts[0].trim(), 10),
                        name: parts[1].trim(),
                        imageUrl: parts[2].trim(),
                        unlockPoints: parseInt(parts[3].trim(), 10),
                        folder: parts[4].trim() || 'Ungrouped'
                    };
                } else if (parts.length >= 4) {
                     return {
                        id: parseInt(parts[0].trim(), 10),
                        name: parts[1].trim(),
                        imageUrl: parts[2].trim(),
                        unlockPoints: parseInt(parts[3].trim(), 10),
                        folder: 'Ungrouped'
                    };
                }
                return null;
            }).filter(item => item !== null);
        }

        /**
         * Selects a random item from the encounterData array, filtered by the current region,
         * using a weighted random selection based on item rarity.
         * @returns {Object} A random encounter item or a placeholder if no data for the region.
         */
        function getRandomEncounterItem() {
            const regionalEncounters = encounterData.filter(item => item.region === currentRegionId);

            if (regionalEncounters.length === 0) {
                return { id: 'N/A', name: `No encounters in ${currentRegionObject ? currentRegionObject.name : 'this region'}`, imageUrl: "https://placehold.co/200x200/FF0000/FFFFFF?text=No+Encounters", points: 0, rarity: 1 };
            }

            let totalWeight = 0;
            const weightedEncounters = regionalEncounters.map(item => {
                const weight = item.rarity > 0 ? 1 / item.rarity : 1;
                totalWeight += weight;
                return { ...item, weight: weight };
            });

            let randomValue = Math.random() * totalWeight;

            for (const item of weightedEncounters) {
                randomValue -= item.weight;
                if (randomValue <= 0) {
                    return item;
                }
            }
            return regionalEncounters[0];
        }

        /**
         * Updates the collection display on the UI.
         * Sorts by ID and displays ID next to the name.
         */
        function updateCollectionDisplay() {
            collectionListElement.innerHTML = '';

            if (collectedItems.size === 0) {
                collectionListElement.innerHTML = '<li class="text-gray-500 italic">No items collected yet.</li>';
                return;
            }

            const collectedItemDetails = Array.from(collectedItems)
                .map(itemName => encounterData.find(item => item.name === itemName))
                .filter(item => item !== undefined)
                .sort((a, b) => parseInt(a.id, 10) - parseInt(b.id, 10));

            collectedItemDetails.forEach(item => {
                const listItem = document.createElement('li');
                listItem.className = 'bg-yellow-200 text-yellow-800 p-2 rounded-md shadow-sm flex items-center justify-between';
                listItem.innerHTML = `<span>#${item.id} - ${item.name}</span>`;
                collectionListElement.appendChild(listItem);
            });
        }

        /**
         * Updates the total points display on the UI.
         */
        function updateTotalPointsDisplay() {
            totalPointsDisplay.textContent = totalPoints;
            renderRegionSelection();
        }

        /**
         * Processes an encounter: updates UI, checks for new items, adds to collection.
         */
        function processEncounter() {
            const item = getRandomEncounterItem();

            encounterNameElement.textContent = item.name;
            encounterImageElement.src = item.imageUrl;
            encounterImageElement.alt = item.name;

            if (!collectedItems.has(item.name)) {
                collectedItems.add(item.name);
                totalPoints += item.points;
                console.log(`New item collected: #${item.id} - ${item.name}, Points gained: ${item.points}`);
                updateCollectionDisplay();
                updateTotalPointsDisplay();
            } else {
                console.log(`Encountered #${item.id} - ${item.name} again.`);
            }

            timerCountdownMs = ENCOUNTER_DURATION_MS;
            lastAnimationFrameTime = performance.now();
            if (timerAnimationId) {
                cancelAnimationFrame(timerAnimationId);
            }
            timerAnimationId = requestAnimationFrame(animateTimerBar);
        }

        /**
         * Animates the timer bar and updates the countdown text.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function animateTimerBar(currentTime) {
            if (!lastAnimationFrameTime) {
                lastAnimationFrameTime = currentTime;
            }

            const elapsed = currentTime - lastAnimationFrameTime;
            lastAnimationFrameTime = currentTime;

            timerCountdownMs -= elapsed;

            if (timerCountdownMs < 0) {
                timerCountdownMs = 0;
            }

            const progress = (timerCountdownMs / ENCOUNTER_DURATION_MS) * 100;
            timerBarElement.style.width = `${progress}%`;

            const secondsLeft = Math.ceil(timerCountdownMs / 1000);
            timerTextElement.textContent = secondsLeft;

            if (timerCountdownMs > 0) {
                timerAnimationId = requestAnimationFrame(animateTimerBar);
            } else {
                timerTextElement.textContent = '0';
            }
        }

        /**
         * Toggles the visibility of a region folder.
         * @param {string} folderName - The name of the folder to toggle.
         */
        function toggleFolder(folderName) {
            const folderContent = document.getElementById(`folder-content-${folderName.replace(/\s/g, '-')}`);
            const folderHeader = document.getElementById(`folder-header-${folderName.replace(/\s/g, '-')}`);

            if (folderContent && folderHeader) {
                const isCollapsed = folderContent.classList.toggle('collapsed');
                folderHeader.classList.toggle('collapsed', isCollapsed);
                folderStates[folderName] = !isCollapsed;
            }
        }

        /**
         * Renders (or re-renders) the region selection buttons and folders.
         * Includes logic for folder organization and completion stars.
         */
        function renderRegionSelection() {
            regionSelectorList.innerHTML = '';

            if (regionData.length === 0) {
                regionSelectorList.innerHTML = '<p class="text-gray-500 italic">No regions loaded.</p>';
                return;
            }

            const regionsByFolder = regionData.reduce((acc, region) => {
                const folderName = region.folder || 'Ungrouped';
                if (!acc[folderName]) {
                    acc[folderName] = [];
                }
                acc[folderName].push(region);
                return acc;
            }, {});

            const sortedFolderNames = Object.keys(regionsByFolder).sort((a, b) => {
                if (a === 'Ungrouped') return 1;
                if (b === 'Ungrouped') return -1;
                return a.localeCompare(b);
            });

            sortedFolderNames.forEach(folderName => {
                const folderRegions = regionsByFolder[folderName];

                // Calculate folder completion
                const allEncountersInFolder = new Set();
                folderRegions.forEach(region => {
                    encounterData.filter(item => item.region === region.id)
                                 .forEach(item => allEncountersInFolder.add(item.name));
                });

                const collectedInFolder = Array.from(collectedItems).filter(itemName => allEncountersInFolder.has(itemName)).length;
                const isFolderComplete = allEncountersInFolder.size > 0 && collectedInFolder === allEncountersInFolder.size;


                const folderHeader = document.createElement('button');
                folderHeader.id = `folder-header-${folderName.replace(/\s/g, '-')}`;
                folderHeader.className = `folder-header w-full flex justify-between items-center px-4 py-2 mb-2 rounded-lg`;
                let folderHeaderText = folderName;
                if (isFolderComplete) {
                    folderHeaderText += ` \u{2B50}`; // Add star for completed folder
                }
                folderHeader.innerHTML = `
                    <span>${folderHeaderText}</span>
                    <span class="arrow-icon text-xl">&#9660;</span>
                `;
                folderHeader.addEventListener('click', () => toggleFolder(folderName));
                regionSelectorList.appendChild(folderHeader);

                const folderContentDiv = document.createElement('div');
                folderContentDiv.id = `folder-content-${folderName.replace(/\s/g, '-')}`;
                folderContentDiv.className = `folder-content space-y-2 mb-2`;
                regionSelectorList.appendChild(folderContentDiv);

                if (folderStates[folderName] === false) {
                    folderContentDiv.classList.add('collapsed');
                    folderHeader.classList.add('collapsed');
                } else if (folderStates[folderName] === true) {
                    folderContentDiv.classList.remove('collapsed');
                    folderHeader.classList.remove('collapsed');
                } else {
                    if (folderRegions.some(region => region.id === currentRegionId)) {
                        folderContentDiv.classList.remove('collapsed');
                        folderHeader.classList.remove('collapsed');
                        folderStates[folderName] = true;
                    } else {
                        folderContentDiv.classList.add('collapsed');
                        folderHeader.classList.add('collapsed');
                        folderStates[folderName] = false;
                    }
                }

                folderRegions.forEach(region => {
                    const button = document.createElement('button');
                    const isLocked = totalPoints < region.unlockPoints;
                    const isActive = region.id === currentRegionId;

                    const encountersInRegion = encounterData.filter(item => item.region === region.id);
                    const uniqueEncountersInRegion = new Set(encountersInRegion.map(item => item.name));
                    const collectedInRegion = Array.from(collectedItems).filter(itemName => uniqueEncountersInRegion.has(itemName)).length;
                    const isRegionComplete = uniqueEncountersInRegion.size > 0 && collectedInRegion === uniqueEncountersInRegion.size;

                    let buttonText = region.name;
                    if (isLocked) {
                        buttonText += ` (${region.unlockPoints} pts)`;
                    }
                    if (isRegionComplete) {
                        buttonText += ` \u{2B50}`;
                    }

                    button.textContent = buttonText;
                    button.className = `w-full px-4 py-2 rounded-lg font-bold shadow-sm transition-all duration-200 text-left`;

                    if (isActive) {
                        button.classList.add('bg-blue-600', 'text-white', 'hover:scale-105');
                    } else if (isLocked) {
                        button.classList.add('bg-gray-300', 'text-gray-600', 'locked-region-button');
                        button.disabled = true;
                    } else {
                        button.classList.add('bg-blue-500', 'text-blue-50', 'hover:bg-blue-600', 'hover:scale-105');
                        button.addEventListener('click', () => changeRegion(region.id));
                    }
                    folderContentDiv.appendChild(button);
                });
            });
        }

        /**
         * Changes the active region of the game.
         * @param {number} newRegionId - The ID of the region to switch to.
         */
        function changeRegion(newRegionId) {
            if (currentRegionId === newRegionId) {
                return;
            }

            const newRegion = regionData.find(r => r.id === newRegionId);
            if (!newRegion) {
                console.error(`Region with ID ${newRegionId} not found.`);
                return;
            }

            if (totalPoints < newRegion.unlockPoints) {
                console.log(`Not enough points to unlock ${newRegion.name}. Need ${newRegion.unlockPoints} points.`);
                return;
            }

            currentRegionId = newRegionId;
            currentRegionObject = newRegion;
            updateRegionDisplay();
            updateCollectionDisplay();
        }

        /**
         * Updates the current region name display and sets the background image.
         */
        function updateRegionDisplay() {
            if (currentRegionObject) {
                currentRegionNameDisplay.textContent = currentRegionObject.name;
                mainEncounterArea.style.backgroundImage = `url('${currentRegionObject.imageUrl}')`;
            } else {
                currentRegionNameDisplay.textContent = 'Unknown Region';
                mainEncounterArea.style.backgroundImage = `url('https://placehold.co/800x600/FF0000/FFFFFF?text=Region+Not+Found')`;
            }
            renderRegionSelection();
        }

        /**
         * Starts the game by initializing data, UI, and the encounter interval.
         */
        async function startGame() {
            encounterNameElement.textContent = 'Loading game data...';
            encounterImageElement.src = 'https://placehold.co/200x200/cccccc/333333?text=Loading...';
            encounterImageElement.alt = 'Loading...';
            currentRegionNameDisplay.textContent = 'Loading...';

            const [encounters, regions] = await Promise.all([
                fetchCSVData(ENCOUNTERS_CSV_URL, parseEncountersCSV),
                fetchCSVData(REGIONS_CSV_URL, parseRegionsCSV)
            ]);

            encounterData = encounters;
            regionData = regions.sort((a, b) => a.id - b.id);

            console.log("Loaded Region Data:", regionData);

            if (encounterData.length === 0 || regionData.length === 0) {
                console.error('Failed to load all necessary game data. Game cannot start.');
                encounterNameElement.textContent = 'Game data failed to load.';
                currentRegionNameDisplay.textContent = 'Error';
                mainEncounterArea.style.backgroundImage = `url('https://placehold.co/800x600/FF0000/FFFFFF?text=Error+Loading')`;
                return;
            }

            currentRegionObject = regionData.find(r => r.id === currentRegionId);
            if (!currentRegionObject) {
                currentRegionObject = regionData[0];
                currentRegionId = regionData[0].id;
            }

            const initialFolder = regionData.find(r => r.id === currentRegionId)?.folder || 'Ungrouped';
            folderStates[initialFolder] = true;

            updateCollectionDisplay();
            updateTotalPointsDisplay();
            updateRegionDisplay();

            processEncounter();
            encounterIntervalId = setInterval(processEncounter, ENCOUNTER_DURATION_MS);
        }

        window.onload = startGame;

        window.onbeforeunload = () => {
            if (encounterIntervalId) {
                clearInterval(encounterIntervalId);
            }
            if (timerAnimationId) {
                cancelAnimationFrame(timerAnimationId);
            }
        };
    </script>
</body>
</html>
